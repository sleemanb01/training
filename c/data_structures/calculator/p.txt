0.

typedef enum 
{
    START,
    WAIT_NUM,
    WAIT_OPERATOR,
    WAIT_NUM_OR_SIGN,
    FAIL /* return 0.0/0.0 -nan */
}states_enum_ty;

typedef enum 
{
    NUM_EP,
    PLUS_MINUS,
    MUL_DIV
}entry_priority_ty;

const size_t NUM_OF_STATES = 5;
const size_t NUM_OF_OP_GROUPS = 3;

typedef enum 
{
    NUM,
    PLUS,
    MINUS,
    MUL,
    DIV
}inputs_enum_ty;

1. define calc struct

typedef struct
{
    stack_t *operands;
    stack_t *operators;
} calculator_ty;

2.define handle struct

    typedef struct
    {
    	states_enum_ty next_state;
    	void func(char *start, calc_ty calc, inputs_enum_ty curr_input);
    }state_ty;

3.define opp struct

    typedef struct
    {
	    double (*action_func)(double double_one, double double_two);
	    int assosiation;
        entry_priority_ty entry_and_priority;
    }input_ty;

4. init state\input LUT
    const state_ty fsm_lut[NUM_OF_STATES][NUM_OF_OP_GROUPS] = { 
                /*start*/                        /*WAIT NUM*/                     /*WAIT OPERATOR*/                      /*WAIT NUM OR SIGN*/
    /*NUM*/     {{WAIT_OPERATOR, &HandleNum},    {WAIT_OPERATOR, &HandleNum},     {FAIL, &DoNothing},                     {WAIT_OPERATOR, &HandleNum}},
    /* + - */   {{WAIT_NUM, &HandleOperator },   {FAIL, &DoNothing},               {WAIT_NUM_OR_SIGN, &HandleOperator},   {WAIT_NUM, &HandleOperator}},
    /* * / */   {{FAIL, &DoNothing},              {FAIL, &DoNothing},               { WAIT_NUM_OR_SIGN, &HandleOperator},  {FAIL, &DoNothing}}
};

5. init opp LUT

inputs_enum_ty char_lut[MAX_CHAR_VALUE];

for i to MAX_CHAR_VALUE do
    lut_input[i] = NONE;
endfor

lut_input['+'] = PLUS;
lut_input['-'] = MINUS;
lut_input['*'] = MULT;
lut_input['/'] = DIV;
lut_input['0'] = NUM;
lut_input['1'] = NUM;
lut_input['2'] = NUM;
lut_input['3'] = NUM;
lut_input['4'] = NUM;
lut_input['5'] = NUM;
lut_input['6'] = NUM;
lut_input['7'] = NUM;
lut_input['8'] = NUM;
lut_input['9'] = NUM;


6. init of
    input_ty input_lut[NUM_OF_OP] = {
        {NULL, NUM_EP}, {&Add, PLUS_MINUS}, {&Subtruct, PLUS_MINUS},{&Devide, MULT_DIV},{&Multiply, MULT_DIV}
    };

7.  create calc struct
        alloc stacks
    
    

8. destroy 
    free stacks
    free calc
    


9. double CalcCulate(const char *str); 
    create (7)
    states_enum_ty curr_state = START;
    state_ty *curr_transition = NULL;
    inputs_enum_ty curr_input = 0;
    char *start = str;
    
    while(input_strint not empty and curr_state not FAIL)
    {
        curr_input = char_lut[*input_strint start];
        
        curr_transition = fsm_lut[curr_state][   input_lut[curr_input]->entry_and_priority   ];      /* get struct from fsm */

        curr_transition->func(char *start, calc_ty calc, inputs_enum_ty curr_input);  
        
        curr_state = curr_transition->next_state;              /* update to next step*/
    }
    

    destroy(8)
10.

priority[input[char]]

void HandleNum(char *start, calc_ty calc, inputs_enum_ty curr_input)
{
    double curr_num;
    
    curr_num = strtod();
    
   StackPush(calc->operands, (void *)curr_num));
    
}

void HandleOperator(char *start, calc_ty calc, inputs_enum_ty curr_input)
{
    inputs_enum_ty prev_operator = 0;
    entry_priority_ty prev_priority = 0;
    
    double num1 = 0;
    double num2 = 0;
    
    op = *(inputs_enum_ty *)StackPeek(calc->operators);
    entry_priority_ty previos_priority = input_lut[op]->entry_and_priority;

    
    if(previos_priority >=  curr_input) /* *,/ > +,- */
    {
        num1 = *(double *)StackPeek(calc->operands);    
        StackPop(calc->operands); 
        
        num2 = *(double *)StackPeek(calc->operands)
        StackPop(calc->operands);
        
        StackPop(calc->operators); 
        
        StackPush(calc->operands, input_lut[op]->action_func(num1,num2)); 
    }
    
    StackPush(calc->operators, curr_input);

    1 + (2 * (1 * 2 + 1)
    1   +
        (1 + 2 + 5 *7 +(1+2))
    6
    "1*"
   " 543 + 55 * 55 *  " <-  fail?

    res     + -nan 
    
    
    
}

const FSM_ty fsm[MAX_INPUT_TYPES][MAX_STATES] = 
                                    {/*start               wait num              wait operator          wait num or sign     */
                          /*num*/   {{WAIT_OPP, NULL},     {WAIT_OPP, NULL},     {FAIL, NULL},          {WAIT_OPP, NULL}     },    
                   /*plus minus*/   {{WAIT_NUM, NULL},     {FAIL, NULL},         {WAIT_NUM_OPP, NULL},  {WAIT_NUM, NULL}     }, 
                 /*multi divide*/   {{FAIL, NULL},         {FAIL, NULL},         {WAIT_NUM_OPP, NULL},  {FAIL, NULL}         }, 
              /*open paranteces*/   {{WAIT_NUM_OPP, NULL}, {WAIT_NUM_OPP, NULL}, {FAIL, NULL},          {WAIT_NUM_OPP, NULL} }, 
            /*closed paranteces*/   {{FAIL, NULL},         {FAIL, NULL},         {WAIT_OPP, NULL},      {FAIL, NULL}         }  
                                    };

void DoNothing(char *start, calc_ty calc, inputs_enum_ty curr_input)
{
    UNUSED(start)
    UNUSED(calc)
    UNUSED(curr_input)
}















